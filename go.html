<script type="text/go" id="ex-go-structure">
package main

import (
  "fmt"
)

func main() {
  fmt.Println("Starting and Ending")
}
</script>
  
<script type="text/go" id="ex-go-control">
if condition {
    fmt.Println("Condition set")
} else if otherCondition && anotherCondition {
    fmt.Println("Other conditions set")
} else {
    fmt.Println("Fell through")
}

for i := 0; i < 100; i++ {
    break;
}
</script>

<script type="text/go" id="ex-go-function">
// Increments the given integer local to the function
func increment(x int) {
    x += 1
}

func plusOne(x int) int {
    return x + 1
}

// Go supports pointers
func incrementDirect(x *int) {
    *x += 1
}
</script>

<script type="text/go" id="ex-go-var">
// Constants 
const myPrivateLimit = 100

// Declarative form, no assignment
var trueVar bool

// Inferred type, no "var" keyword required
trueVar := true
name := "wally"
var isNull MyClass

isNull = nil

// Note that arrays/slices are fixed length and must be grown manually
names := []string{"hello", "world"}
kvs := map[string]string{"hello":"world"}
</script>

<script type="text/go" id="ex-go-string">
// Strings are immutable and declared implicitly
str := "bananas";

// String literals are always UTF-8 encoded, since go source files must be encoded in UTF8

// Concatenation via + operator
strcat := "hello " + "world";

// String equality via == or strings.Compare
if strcat == "hello world" {
}

// Total number of bytes in the string
len := len(strcat)

// Gets the byte at index 0
c := strcat[0]

fmt.Println(strings.Index(str, "ba"))

// The for..range construct will iterate over UTF8 code points
for index, runeValue := range strcat {
    fmt.Printf("%#U starts at byte position %d\n", runeValue, index)
}
</script>

<script type="text/go" id="ex-go-map">
// Given a list of string terms, find the one that occurs most often
func MostCommonTerm(terms []string) string {
    termMap := make(map[string]int)

    for _, term := range terms {
        if count, ok := termMap[term]; ok {
            termMap[term] = count + 1
        } else {
            termMap[term] = 1
        }
    }

    max := 0
    var result string

    for key, value := range termMap {
        if value > max {
            result = key
            max = value
        }
    }

    delete(termMap, result)

    return result
}
</script>

<script type="text/go" id="ex-go-class">
</script>

<script type="text/go" id="ex-go-regex">
</script>

<script type="text/go" id="ex-go-datetime">
</script>

<script type="text/php" id="ex-go-io2">
</script>

<script type="text/go" id="ex-go-namespace">
</script>
