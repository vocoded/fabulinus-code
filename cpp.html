<script type="text/cpp" id="ex-cpp-structure">
// Exactly one file in the compiled unit defines a main method:
int main(int argc, char* argv[])
{
}
</script>

<script type="text/cpp" id="ex-cpp-control">
int main(int argc, char* argv[])
{
    if (condition) {
        std::cout << "Condition set" << std::endl;
    } else if (other_condition && another_condition) {
        std::cout << "Other conditions set" << std::endl;
    } else {
        std::cout << "Fell through" << std::endl;
    }

    std::string value = condition ? "Condition is truthy!" : "Condition is falsy!";

    for (int i = 0; i < 100; i++) {
        break;
    }

    std::vector<int> values = {1, 2, 3};
    std::for_each(values.begin(), values.end(), [](int &n) { std::cout << n << std::endl; });
}
</script>

<script type="text/cpp" id="ex-cpp-function">
// Increments the given integer local to the function
void increment(int x)
{
    x += 1;
}

// Modifying the argument requires passing it by reference or pointer
void add_concat(std::vector<std::string>& terms)
{
    // Unfortunately there's no std::vector.join()
    std::ostringstream os;
    std::copy(terms.begin(), terms.end() - 1, std::ostream_iterator<std::string>(os, ""));
    os << *terms.rbegin();

    terms.push_back(os.str());

    // Unlike Java and C#, assigning the reference to another object will carry beyond the method
    terms = { "1", "2", "3" };
}

// Method marked constant so it can be called on a constant variable/reference
std::string MyClass::getValue() const
{
    return m_value + "!";
}

// Generally you won't return references unless providing mutable access to a long-lived
// data member, such as an instance field.  Even then, cases ought to be limited to things
// a subscript overload (ie, so you can create an lvalue such as myObject[key] = "xyz")
std::string& MyClass:getValue()
{
    return m_value;
}

// Lambdas have different captures modes:
[=] { std::cout << val << std::endl; }  // All outer variables by value
[&] { std::cout << val << std::endl; }  // All outer variables by reference
</script>

<script type="text/cpp" id="ex-cpp-map">
// Given a list of string terms, find the one that occurs most often
std::string most_common_term(const std::vector<std::string>& terms)
{
    std::map<std::string, int> term_map;

    for (auto const &term : terms) {
        // Alternately, term_map.count(term) == 0
        if (term_map.find(term) != term_map.end()) {
            term_map[term] += 1;
        } else {
            term_map[term] = 1;
        }
    }

    int max = 0;
    std::string result;

    for (auto const &kv : term_map) {
        if (kv.second > max) {
            result = kv.first;
            max = kv.second;
        }
    }

    return result;
}

</script>

<script type="text/cpp" id="ex-cpp-var">
bool true_var = true;
int *null_var = nullptr;

// Unlike other languages, variables are instantiated when defined
MyClass mine;  // Creates a new object of the type MyClass using the default constructor

std::vector<std::string> ary = { "hello", "world" };
std::map<std::string, std::string> ary = {{"hello", "world"}};
</script>

<script type="text/cpp" id="ex-cpp-string">
// There are two types of strings - standard C strings of char*, and std::string
std::string str = "bananas";
// They are mutable and do not support interpolation
// Concatenation via + operator
std::string strcat = "hello ";
strcat += "world";

std::cout << strcat.length() << std::endl;

// Alternatively, strcat.at(0)
std::cout << strcat[0] << std::endl;

if (!str.compare("bananas")) {
    std::cout << "Strings are equal!" << std::endl;
}
</script>

<script type="text/cpp" id="ex-cpp-regex">
#include <regex>

const char subject[] = "hello world";
std::regex pattern ("^hello");
std::cmatch cm;
std::regex_match (subject, cm, pattern);

if (cm.size()) {
    std::cout << cm[0] << std::endl;
}
</script>

<script type="text/cpp" id="ex-cpp-datetime">
time_t seconds = std::time(0);
</script>

<script type="text/cpp" id="ex-cpp-namespace">
namespace utils
{
    void computeAverage(std::vector<int>& values)
    {
    }
}

utils::computeAverage(vals);

// Generally not recommended - imports all from the namespace
using namespace utils;

// Using declaration - makes only the given name available
using utils::computeAverage;
</script>