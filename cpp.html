<script type="text/cpp" id="ex-cpp-structure">
// Exactly one file in the compiled unit defines a main method:
int main(int argc, char* argv[])
{
}
</script>

<script type="text/cpp" id="ex-cpp-control">
#include "stdafx.h"

int main(int argc, char* argv[])
{
    bool true_var = true;
    int *null_var = nullptr;

    if (condition) {
        std::cout << "Condition set" << std::endl;
    } else if (other_condition && another_condition) {
        std::cout << "Other conditions set" << std::endl;
    } else {
        std::cout << "Fell through";
    }

    std::string value = condition ? "Condition is truthy!" : "Condition is falsy!";

    for (int i = 0; i < 100; i++) {
        break;
    }

    std::vector<int> values = {1, 2, 3};
    std::for_each(values.begin(), values.end(), [](int &n) { std::cout << n << std::endl; });
}
</script>

<script type="text/cpp" id="ex-cpp-function">
// Increments the given integer local to the function
void increment(int x)
{
    x += 1;
}

// Modifying the argument requires passing it by reference or pointer
void add_concat(std::vector<std::string>& terms)
{
    // Unfortunately there's no std::vector.join()
    std::ostringstream os;
    std::copy(elements.begin(), elements.end() - 1, std::ostream_iterator<std::string>(os, ""));
    os << *elements.rbegin();

    terms.push_back(os.str());
}
</script>

<script type="text/cpp" id="ex-cpp-map">
// Given a list of string terms, find the one that occurs most often
std::string most_common_term(std::vector<std::string> terms)
{
    std::map<std::string, int> term_map;

    for (auto const &term : terms) {
        if (term_map.find(term) != term_map.end()) {
            term_map[term] += 1;
        } else {
            term_map[term] = 1;
        }
    }

    int max = 0;
    std::string result;

    for (auto const &kv : term_map) {
        if (kv.second > max) {
            result = kv.first;
            max = kv.second;
        }
    }

    return result;
}

</script>

<script type="text/cpp" id="ex-cpp-var">
std::vector<std::string> ary = { "hello", "world" };
std::map<std::string, std::string> ary = {{"hello", "world"}};
</script>

<script type="text/cpp" id="ex-cpp-string">
// There are two types of strings - standard C strings of char*, and std::string
std::string str = "bananas";
// They are mutable and do not support interpolation
// Concatenation via + operator
std::string strcat = "hello ";
strcat += "world";

std::cout << strcat.length() << std::endl;
// Alternatively, strcat.at(0)
std::cout << strcat[0] << std::endl;
</script>

<script type="text/cpp" id="ex-cpp-regex">
#include <regex>

const char subject[] = "hello world";
std::regex pattern ("^hello");
std::cmatch cm;
std::regex_match (subject, cm, pattern);

if (cm.size()) {
    std::cout << cm[0] << std::endl;
}
</script>

<script type="text/cpp" id="ex-cpp-datetime">
time_t seconds = std::time(0);
</script>

<script type="text/cpp" id="ex-cpp-namespace">
namespace utils
{
    void computeAverage(std::vector<int> values)
    {
    }
}

utils::computeAverage(vals);

// Generally not recommended - imports all from the namespace
using namespace utils;

// Using declaration - makes only the given name available
using utils::computeAverage;
</script>